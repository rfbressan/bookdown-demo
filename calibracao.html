<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Capítulo 5 Métodos de Calibração | Introdução a Superfície de Volatilidade</title>
  <meta name="description" content="Gitbook sobre superfícies de volatilidade para o Clube de Finanças ESAG.">
  <meta name="generator" content="bookdown  and GitBook 2.6.7">

  <meta property="og:title" content="Capítulo 5 Métodos de Calibração | Introdução a Superfície de Volatilidade" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Gitbook sobre superfícies de volatilidade para o Clube de Finanças ESAG." />
  <meta name="github-repo" content="rfbressan/vol_surface_gitbook" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Capítulo 5 Métodos de Calibração | Introdução a Superfície de Volatilidade" />
  
  <meta name="twitter:description" content="Gitbook sobre superfícies de volatilidade para o Clube de Finanças ESAG." />
  

<meta name="author" content="Rafael Felipe Bressan">


<meta name="date" content="2019-01-26">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="smile.html">
<link rel="next" href="svi.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script src="libs/kePrint-0.0.1/kePrint.js"></script>
<link href="libs/bsTable-3.3.7/bootstrapTable.min.css" rel="stylesheet" />


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Introdução a Superfície de Volatilidade</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Prefácio</a></li>
<li class="chapter" data-level="" data-path="sobre-os-autores.html"><a href="sobre-os-autores.html"><i class="fa fa-check"></i>Sobre os Autores</a><ul>
<li class="chapter" data-level="" data-path="sobre-os-autores.html"><a href="sobre-os-autores.html#rafael-felipe-bressan"><i class="fa fa-check"></i>Rafael Felipe Bressan</a></li>
<li class="chapter" data-level="" data-path="sobre-os-autores.html"><a href="sobre-os-autores.html#erik-naoki-kawano"><i class="fa fa-check"></i>Erik Naoki Kawano</a></li>
<li class="chapter" data-level="" data-path="sobre-os-autores.html"><a href="sobre-os-autores.html#glauber-naue"><i class="fa fa-check"></i>Glauber Naue</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="opcoes.html"><a href="opcoes.html"><i class="fa fa-check"></i><b>1</b> Introdução as opções</a><ul>
<li class="chapter" data-level="1.1" data-path="opcoes.html"><a href="opcoes.html#conceitos-in-the-money-at-the-money-e-out-the-money"><i class="fa fa-check"></i><b>1.1</b> Conceitos in the money, at the money e out the money</a></li>
<li class="chapter" data-level="1.2" data-path="opcoes.html"><a href="opcoes.html#modelos-americano-e-europeu-de-opcoes"><i class="fa fa-check"></i><b>1.2</b> Modelos americano e europeu de opções</a></li>
<li class="chapter" data-level="1.3" data-path="opcoes.html"><a href="opcoes.html#hedge"><i class="fa fa-check"></i><b>1.3</b> Hedge</a></li>
<li class="chapter" data-level="1.4" data-path="opcoes.html"><a href="opcoes.html#travas"><i class="fa fa-check"></i><b>1.4</b> Travas</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="processos-estocasticos.html"><a href="processos-estocasticos.html"><i class="fa fa-check"></i><b>2</b> Processos Estocásticos em Finanças</a><ul>
<li class="chapter" data-level="2.1" data-path="processos-estocasticos.html"><a href="processos-estocasticos.html#markov"><i class="fa fa-check"></i><b>2.1</b> Processos de Markov</a></li>
<li class="chapter" data-level="2.2" data-path="processos-estocasticos.html"><a href="processos-estocasticos.html#mb"><i class="fa fa-check"></i><b>2.2</b> Movimento Browniano</a></li>
<li class="chapter" data-level="2.3" data-path="processos-estocasticos.html"><a href="processos-estocasticos.html#definicao"><i class="fa fa-check"></i><b>2.3</b> Definição</a></li>
<li class="chapter" data-level="2.4" data-path="processos-estocasticos.html"><a href="processos-estocasticos.html#mbg"><i class="fa fa-check"></i><b>2.4</b> Movimento Browniano Geométrico</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="bsm.html"><a href="bsm.html"><i class="fa fa-check"></i><b>3</b> Modelo Black-Scholes-Merton</a><ul>
<li class="chapter" data-level="3.1" data-path="bsm.html"><a href="bsm.html#portfolio-de-replicacao"><i class="fa fa-check"></i><b>3.1</b> Portfólio de replicação</a></li>
<li class="chapter" data-level="3.2" data-path="bsm.html"><a href="bsm.html#precificacao-neutra-ao-risco"><i class="fa fa-check"></i><b>3.2</b> Precificação neutra ao risco</a></li>
<li class="chapter" data-level="3.3" data-path="bsm.html"><a href="bsm.html#encontrando-a-equacao-de-black-scholes"><i class="fa fa-check"></i><b>3.3</b> Encontrando a equação de Black-Scholes</a></li>
<li class="chapter" data-level="3.4" data-path="bsm.html"><a href="bsm.html#solucao-analitica"><i class="fa fa-check"></i><b>3.4</b> Solução analítica</a></li>
<li class="chapter" data-level="3.5" data-path="bsm.html"><a href="bsm.html#putcallparity"><i class="fa fa-check"></i><b>3.5</b> Paridade compra e venda</a></li>
<li class="chapter" data-level="3.6" data-path="bsm.html"><a href="bsm.html#gregas"><i class="fa fa-check"></i><b>3.6</b> As Gregas</a><ul>
<li class="chapter" data-level="3.6.1" data-path="bsm.html"><a href="bsm.html#delta"><i class="fa fa-check"></i><b>3.6.1</b> Delta</a></li>
<li class="chapter" data-level="3.6.2" data-path="bsm.html"><a href="bsm.html#gamma"><i class="fa fa-check"></i><b>3.6.2</b> Gamma</a></li>
<li class="chapter" data-level="3.6.3" data-path="bsm.html"><a href="bsm.html#theta"><i class="fa fa-check"></i><b>3.6.3</b> Theta</a></li>
<li class="chapter" data-level="3.6.4" data-path="bsm.html"><a href="bsm.html#vega"><i class="fa fa-check"></i><b>3.6.4</b> Vega</a></li>
<li class="chapter" data-level="3.6.5" data-path="bsm.html"><a href="bsm.html#rho"><i class="fa fa-check"></i><b>3.6.5</b> Rho</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="smile.html"><a href="smile.html"><i class="fa fa-check"></i><b>4</b> Smile de Volatilidade</a><ul>
<li class="chapter" data-level="4.1" data-path="smile.html"><a href="smile.html#reparametrizando"><i class="fa fa-check"></i><b>4.1</b> Reparametrizando B&amp;S e definição de moneyness</a></li>
<li class="chapter" data-level="4.2" data-path="smile.html"><a href="smile.html#caracsmile"><i class="fa fa-check"></i><b>4.2</b> Características de smiles de volatilidade</a><ul>
<li class="chapter" data-level="4.2.1" data-path="smile.html"><a href="smile.html#mercados-cambiais"><i class="fa fa-check"></i><b>4.2.1</b> Mercados cambiais</a></li>
<li class="chapter" data-level="4.2.2" data-path="smile.html"><a href="smile.html#mercados-de-equities"><i class="fa fa-check"></i><b>4.2.2</b> Mercados de <em>equities</em></a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="smile.html"><a href="smile.html#smileprecificacao"><i class="fa fa-check"></i><b>4.3</b> Smile como forma de precificação</a></li>
<li class="chapter" data-level="4.4" data-path="smile.html"><a href="smile.html#estrutura-a-termo"><i class="fa fa-check"></i><b>4.4</b> Estrutura a termo</a></li>
<li class="chapter" data-level="4.5" data-path="smile.html"><a href="smile.html#arbestatica"><i class="fa fa-check"></i><b>4.5</b> Arbitragem estática</a><ul>
<li class="chapter" data-level="4.5.1" data-path="smile.html"><a href="smile.html#arbitragem-de-borboleta"><i class="fa fa-check"></i><b>4.5.1</b> Arbitragem de borboleta</a></li>
<li class="chapter" data-level="4.5.2" data-path="smile.html"><a href="smile.html#arbitragem-de-calendario"><i class="fa fa-check"></i><b>4.5.2</b> Arbitragem de calendário</a></li>
</ul></li>
<li class="chapter" data-level="4.6" data-path="smile.html"><a href="smile.html#limites-de-inclinacao"><i class="fa fa-check"></i><b>4.6</b> Limites de inclinação</a></li>
<li class="chapter" data-level="4.7" data-path="smile.html"><a href="smile.html#distribuicao-implicita"><i class="fa fa-check"></i><b>4.7</b> Distribuição implícita</a></li>
<li class="chapter" data-level="4.8" data-path="smile.html"><a href="smile.html#conclusao"><i class="fa fa-check"></i><b>4.8</b> Conclusão</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="calibracao.html"><a href="calibracao.html"><i class="fa fa-check"></i><b>5</b> Métodos de Calibração</a><ul>
<li class="chapter" data-level="5.1" data-path="calibracao.html"><a href="calibracao.html#calibracao-versus-interpolacao"><i class="fa fa-check"></i><b>5.1</b> Calibração versus Interpolação</a></li>
<li class="chapter" data-level="5.2" data-path="calibracao.html"><a href="calibracao.html#spline-cubica"><i class="fa fa-check"></i><b>5.2</b> Spline cúbica</a></li>
<li class="chapter" data-level="5.3" data-path="calibracao.html"><a href="calibracao.html#suavizacao"><i class="fa fa-check"></i><b>5.3</b> Suavização</a></li>
<li class="chapter" data-level="5.4" data-path="calibracao.html"><a href="calibracao.html#parametrizacao"><i class="fa fa-check"></i><b>5.4</b> Parametrização</a><ul>
<li class="chapter" data-level="5.4.1" data-path="calibracao.html"><a href="calibracao.html#funcao-perda"><i class="fa fa-check"></i><b>5.4.1</b> Função perda</a></li>
<li class="chapter" data-level="5.4.2" data-path="calibracao.html"><a href="calibracao.html#otimizadores"><i class="fa fa-check"></i><b>5.4.2</b> Otimizadores</a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="calibracao.html"><a href="calibracao.html#conclusao-1"><i class="fa fa-check"></i><b>5.5</b> Conclusão</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="svi.html"><a href="svi.html"><i class="fa fa-check"></i><b>6</b> Calibrando uma SVI</a><ul>
<li class="chapter" data-level="6.1" data-path="svi.html"><a href="svi.html#modelo-svi"><i class="fa fa-check"></i><b>6.1</b> Modelo SVI</a></li>
<li class="chapter" data-level="6.2" data-path="svi.html"><a href="svi.html#restricoes-de-nao-arbitragem"><i class="fa fa-check"></i><b>6.2</b> Restrições de não-arbitragem</a></li>
<li class="chapter" data-level="6.3" data-path="svi.html"><a href="svi.html#reparametrizacao-quasi-explicit"><i class="fa fa-check"></i><b>6.3</b> Reparametrização Quasi-explicit</a><ul>
<li class="chapter" data-level="6.3.1" data-path="svi.html"><a href="svi.html#pq"><i class="fa fa-check"></i><b>6.3.1</b> Solução explícita do problema reduzido</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="svi.html"><a href="svi.html#algoritmo"><i class="fa fa-check"></i><b>6.4</b> Algoritmo</a></li>
<li class="chapter" data-level="6.5" data-path="svi.html"><a href="svi.html#resultados"><i class="fa fa-check"></i><b>6.5</b> Resultados</a></li>
<li class="chapter" data-level="6.6" data-path="svi.html"><a href="svi.html#conclusao-2"><i class="fa fa-check"></i><b>6.6</b> Conclusão</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="bibliografia.html"><a href="bibliografia.html"><i class="fa fa-check"></i>Bibliografia</a></li>
<li class="divider"></li>
<li><a href="https://bookdown.org/" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Introdução a Superfície de Volatilidade</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="calibracao" class="section level1">
<h1><span class="header-section-number">Capítulo 5</span> Métodos de Calibração</h1>
<p>Neste post iremos mostrar as diferenças existentes entre “interpolação”, “suavização” e “parametrização” de superfícies de volatilidade.</p>
<p>Como já apresentado em posts anteriores, existem diversas formas de interpolar, extrapolar, parametrizar e calibrar smiles de volatilidade. Exsitem vantagens e desvantagens para cada método.</p>
<div id="calibracao-versus-interpolacao" class="section level2">
<h2><span class="header-section-number">5.1</span> Calibração versus Interpolação</h2>
<p>Uma forma simples de gerar um smile de volatilidade a partir de dados observados no mercado é a <strong>interpolação</strong> destes dados. Diversas formas de interpolação existem, sendo talvez a mais conhecida a spline cúbica. Não é a proposta deste artigo detalhar os procedimentos de interpolação, restando saber que em tal procedimento é gerada uma função contínua em partes (piecewise) que <strong>passa</strong> por todos os pontos observados.</p>
<p>Uma interpolação força a passagem da função interpolada em todos os seus pontos de referência, como se estivesse ligando os pontos em um desenho a mão livre. Portanto, nestes pontos o erro da interpolação é zero por definição, entretanto em pontos intermediários podem surgir erros, inclusive aqueles que possibilitam a existência de arbitragem entre strikes de um mesmo smile<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>.</p>
<p>Em contraposição a métodos de interpolação, podem ser derivados métodos de suavização (smoothing) ou então a parametrização do smile de volatilidade. Seja suavização, ou parametrização, estes métodos não forçam a passagem da função que representa o smile pelos pontos de mercado, mas buscam minimizar alguma função perda com relação aos desvios em relação a estes pontos ao mesmo tempo em que buscam “suavizar” o smile, para que este não apresente variações bruscas entre os strikes ou alterações de convexidade na curva de preços, que não são condizentes com a teoria de precificação de derivativos.</p>
<p>Um método paramétrico, como o SVI, Heston, SABR ou Volatilidade Local, busca ajustar às volatilidades implícitas observadas através dos preços das opções sendo praticados no mercado uma determinada função, que possui parâmetros em sua definição que por sua vez determinam a forma desta função. Ao se ajustar os parâmetros, pode-se adequar a função para ficar “o mais próxima possível” dos dados observados, sem necessariamente, no entanto, passar por todos estes pontos.</p>
<p>A figura abaixo tenta mostrar as diferenças entre uma interpolação spline cúbica, uma suavização e uma parametrização SVI. Enquanto que a interpolação liga todos os pontos marcados, a suavização e a parametrização não necessariamente passam sobre estes pontos mas fornecem uma curva mais “suave”, sem trocas de convexidade, o que gera oportunidades de arbitragem e probabilidades negativas de ocorrência de determinados preços para o ativo subjacente, que ferem os princípios de precificação de opções. Os dados utilizados neste e nos próximos artigos sobre superfícies de volatlidade foram obtidos do site <a href="http://www.ivolatility.com/doc/usa/IV_Raw_Delta_surface.csv">ivolatility.com</a> na forma de amostra gratuita fornecida livremente. O ativo subjacente é o ETF <a href="https://www.ishares.com/us/products/239710/ishares-russell-2000-etf"><code>IWM</code></a> para a data de 21/09/2017.</p>
<div class="figure"><span id="fig:diferencas"></span>
<img src="06-metodos-calibracao_files/figure-html/diferencas-1.png" alt="Diferentes métodos de ajuste de dados a um smile." width="672" />
<p class="caption">
Figura 5.1: Diferentes métodos de ajuste de dados a um smile.
</p>
</div>
<p>Pode-se verificar como os métodos SVI e a suavização não passam sobre todos os pontos marcados, com a suavização tendo dificuldade com a curvatura nos valores mais altos de <em>moneyness</em> e a SVI possuindo uma inclinação mais branda na asa esquerda do smile.</p>
</div>
<div id="spline-cubica" class="section level2">
<h2><span class="header-section-number">5.2</span> Spline cúbica</h2>
<p>Este método é possivelmente um dos mais flexíveis e conhecidos de interpolação de dados univariados existente, embora também exista sua versão bi-dimensional. Uma spline nada mais é que “uma curva definida matematicamente por dois ou mais pontos de controle”<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>.</p>
<p>No caso da spline cúbica, esta é uma função polinomial de grau 3 definida em cada subintervalo demarcados pelos pontos de controle, no caso de interpolação são todos nós. Ou seja, considere um segmento entre dois pontos consecutivos <span class="math inline">\([c, d]\in S\)</span> a spline é uma função cúbica com seus parâmetros calculados pelo algoritmo de ajuste. Para o próximo intervalo de pontos dentro do domínio da função, um novo polinômio de grau 3 é ajustado, sendo que nos pontos de nós uma restrição de igualdade entre as derivadas nos dois segmentos é aplicada para garantir a suavidade da função interpolada como um todo.</p>
<p>Assim, uma spline cúbica é uma função contínua, suave e diferenciável até a segunda ordem. Entretanto, suas derivadas, apesar de contínuas, podem não ser suaves, especialmente aquela de segunda ordem que pode apresentar pontos de “ruptura”. Esta característica de uma spline cúbica a torna pouco atrativa para a inferência de distribuições de probabilidade a partir de dados de volatilidade ou mesmo dos preços de opções.</p>
<div class="figure"><span id="fig:cubic-spline"></span>
<img src="images/cubic_spline.png" alt="Cada segmento de uma spline cúbica é um polinômio de grau 3 diferente."  />
<p class="caption">
Figura 5.2: Cada segmento de uma spline cúbica é um polinômio de grau 3 diferente.
</p>
</div>
</div>
<div id="suavizacao" class="section level2">
<h2><span class="header-section-number">5.3</span> Suavização</h2>
<p>A técnica de suavização é muito semelhante a interpolação, inclusive o método spline também é aplicado, com algumas modificações de forma que nem todos os pontos fornecidos serão nós.</p>
<p>Na spline de suavização (ou aproximação), os pontos fornecidos são separados entre os nós, onde a função deve passar e pontos de controle, que são utilizados para controlar a curvatura da função nestes pontos.</p>
<p>Estas suavizações são principalmente utilizadas quando se possui muitas observações sujeitas a ruídos, de forma que uma interpolação entre todos os pontos seria tanto impraticável quanto sem sentido. O que se deseja, portanto, é uma função <strong>aproximada</strong> que melhor descreva o processo sob análise.</p>
<p>Um ponto em comum entre estas técnicas é o parâmetro de suavização, ausente, na interpolação, que controla a “suavidade” da função estimada.</p>
<div class="figure"><span id="fig:suavizacao"></span>
<img src="06-metodos-calibracao_files/figure-html/suavizacao-1.png" alt="Menor parâmetro de suavização gera granularidade na curva." width="672" />
<p class="caption">
Figura 5.3: Menor parâmetro de suavização gera granularidade na curva.
</p>
</div>
</div>
<div id="parametrizacao" class="section level2">
<h2><span class="header-section-number">5.4</span> Parametrização</h2>
<p>E por fim as técnicas de parametrização. Nesta categoria estão diversos conhecidos modelos de superfícies de volatilidade implícita, dentre eles os modelos de <span class="citation">Heston (<a href="#ref-Heston1993">1993</a>)</span>, Volatilidade Local de <span class="citation">Dupire (<a href="#ref-Dupire1994">1994</a>)</span> e SVI de <span class="citation">Gatheral (<a href="#ref-Gatheral2004">2004</a>)</span>.</p>
<p>Em comum, estes modelos tentam parametrizar a superfície, e por conseguinte o smile de volatilidade, de acordo com alguma função, em geral não-linear, que possui características condizentes com a teoria de precificão de derivativos e também a observação empírica das superfícies.</p>
<p>Por exemplo, a parametrização <em>raw</em> da SVI possui a seguinte forma para a <strong>variância total</strong><a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a> :</p>
<p><span class="math display">\[ w(k) = a + b\left(\rho(k-m)+\sqrt{(k-m)^2 + \sigma^2}\right)\]</span></p>
<p>que fornece um espaço de cinco parâmetros <span class="math inline">\(\chi_B=\{a, b, \rho, m, \sigma\}\)</span> que definem o smile e devem, portanto, serem calibrados a partir de dados observados no mercado.</p>
<p>O procedimento de calibração consiste em encontrar o conjunto de parâmetros que minimizam uma função perda entre a volatilidade prevista pelo modelo e os dados de mercado, enquanto satisfazem algumas restrições adicionais, como “ausência de arbitragem”, suavidade, etc. Trata-se, via de regra, de problemas de otimização não-linear com restrições de inequalidade também não-lineares.</p>
<div id="funcao-perda" class="section level3">
<h3><span class="header-section-number">5.4.1</span> Função perda</h3>
<p>A função perda, ou função de calibração pode ser definida de diversas maneiras, de forma geral, para uma determinada maturidade, ela toma a forma:</p>
<p><span class="math display">\[L=\sum\limits_{i=1}^n\lambda_i||\hat w(k_i)-w_{imp}(k_i)||\]</span> onde <span class="math inline">\(||\cdot||\)</span> é alguma medida de norma, sendo a mais conhecida o quadrado das diferenças, dando origem a minimização do erro quadrático médio (RMSE). Para este smile sendo calibrado existem <span class="math inline">\(n\)</span> strikes (<span class="math inline">\(k_i\)</span>) e suas volatilidades implícitas observadas são <span class="math inline">\(w_{imp}(k_i)\)</span>. A resposta do modelo para um determinado strike é <span class="math inline">\(\hat w(k_i)\)</span> e <span class="math inline">\(\lambda_i\)</span> são os pesos dados na função perda para cada um destes strikes.</p>
<p>Os pesos <span class="math inline">\(\lambda_i\)</span> são utilizados para ponderar as observações das volatilidades mais importantes para o cálculo, onde se deseja que a curva ajustada possua um menor erro. Em geral, estes pesos são calculado como inversamente proporcionais:</p>
<ul>
<li>ao quadrado dos <em>spreads bid-ask</em>, para dar mais importância às opções mais líquidas</li>
<li>ao quadrado da grega vega calculada a partir do modelo BSM</li>
</ul>
</div>
<div id="otimizadores" class="section level3">
<h3><span class="header-section-number">5.4.2</span> Otimizadores</h3>
<p>Os otimizadores são os algoritmos pelos quais o problema de minimização posto é resolvido. Se a função perda é convexa, e ela deve ser construída de forma a ser, mesmo que não estritamente, então ela possui um ou mais pontos de mínimo onde o gradiente desta função é igual a zero. O que os otimizadores fazem é buscar o conjunto de parâmetros que minimizam a função perda e atendem as restrições impostas simultaneamente. Os otimizadores podem ser classificados em dois grandes grupos, globais e locais.</p>
<p>Algoritmos locais dependem de uma estimativa inicial dos parâmetros para começarem a busca pelo mínimo. Seguindo uma regra utilizando-se o gradiente da função ou alguma heurística, estes otimizadores caminham em direção ao ponto de mínimo mais próximo da estimativa inicial, daí o nome “local”. Como desvantagem destes otimizadores é a mais evidente é que se a função perda for altamente não-linear, com diversos pontos de mínimo local, este otimizador pode ficar preso em um destes pontos sem nunca, no entanto, encontrar o mínimo global. Eles são, portanto muito sensíveis à estimativa inicial dos parâmetros.</p>
<p>Por sua vez, otimizadores globais buscam mapear todo o espaço factível para os parâmetros e encontrar o ponto mínimo da função perda dentro deste espaço. Estes algoritmos não dependem de estimativas iniciais, uma vez que tentarão avaliar o espaço completo. São utilizados quando o problema de minimização é não-linear e possui múltiplos pontos de mínimo local. Estes algoritmos usam alguma forma de heurística para encontrar a região onde o mínimo global está localizado, mas são, em geral, ineficientes em apontar rapidamente onde este ponto de mínimo se encontra com precisão. Por esta razão, é frequente a utilização de otimizadores globais com um posterior refinamento de sua solução por algum algoritmo local.</p>
<p>Abaixo apresentamos alguns exemplos mais comuns de otimizadores, tanto locais quanto globais:</p>
<ul>
<li><p><strong>Gauss-Newton</strong>: Este método é utilizado para encontrar as raízes de alguma função. Para encontrar o ponto de mínimo da função perda, precisa-se encontrar as raízes do gradiente desta função, portanto o método de Newton em otimização faz uso da função gradiente. Este é um método de otimização local.</p></li>
<li><p><strong>Levenberg-Marquardt</strong>: Método muito utilizado para problemas não-lineares, ele parte de uma modificação ao método de Gauss-Newton ao introduzir um fator de amortecimento calculado iterativamente.</p></li>
<li><p><strong>L-BFGS-B</strong>: BFGS é um método conhecido como quasi-Newton, onde não é necessário calcular a Hessiana do problema, ela é aproximada a partir do próprio gradiente. É bastante utilizado para resolver problemas não-lineares e em sua versão L-BFGS-B pode lidar com restrições do tipo <em>box</em>, intervalo dos parâmetros é fixo.</p></li>
<li><p><strong>Nelder-Mead</strong>: Este é um método livre do uso de gradiente, já que usa uma heurística para construir um simplex e a partir deste “procurar” por um mínimo. Bastante utilizado quando a função objetivo pode não ser diferenciável. Faz uso de um simplex inicial, que pode ser grande o suficiente para encampar o mínimo global, entretanto, não se classifica como um otimizador global.</p></li>
<li><p><strong>Algoritmo Genético</strong>: Este método utiliza conceitos da seleção natural para gerar os resultados da otimização. É um otimizador global, no sentido que independe de uma estimativa inicial de parâmetros e faz uma busca por todo o espaço factível. Em um algoritmo genético, uma população aleatória inicial de parâmetros é criada e a partir desta, as gerações evoluem conforme mutações e <em>cross-over</em> de características e é avaliado o <em>fitness</em> de cada conjunto de parâmetros até um deles ser considerado adequado.</p></li>
<li><p><strong>Evolução Diferencial</strong>: É um método de otimização global, assim como o Algoritmo Genético e o Enxame de Partículas. Sua diferença reside no fato de que sua população inicial é constantemente avaliada e deslocada de posição. Se o agente obtiver uma situação melhor (menor valor para a função perda) na nova posição, esta agora faz parte da população. Desta forma os agentes, antes espalhados pelo espaço factível dos parâmetros, tendem a convergir para um ponto com o menor valor da função perda.</p></li>
<li><p><strong>Enxame de Partículas</strong>: Do inglês, <em>Particle Swarm Optimization - PSO</em> este método é semelhante ao DE <em>(Differential Evolution)</em> porém as partículas (o equivalente dos agentes no DE) matém informações sobre a posição da melhor partícula até então, de forma a fazer com que as partículas tendam para a melhor solução.</p></li>
</ul>
</div>
</div>
<div id="conclusao-1" class="section level2">
<h2><span class="header-section-number">5.5</span> Conclusão</h2>
<p>Dependendo do objetivo da aplicação, superfícies de volatilidade podem ser interpoladas, suavizadas ou parametrizadas. A parametrização tem recebido especial interesse pois pode, ao mesmo tempo que garante uma superfície livre de arbitragem estática se devidamente construída, ajustar-se muito bem aos dados observados e gerar distribuições neutras ao risco implícitas factíveis.</p>
<p>Para gerar uma superfície parametrizada, primeiramente é necessário um modelo teórico com propriedades desejáveis e que se ajuste aos dados de mercado quando calibrado. Escolhido este modelo paramétrico, passa-se a calibração do mesmo onde exsitem diversas opções de escolha entre otimizadores. Ao final do processo teremos um modelo de superfície devidamente parametrizado com valores que melhor se ajustam segundo alguma função perda escolhida.</p>
<p>Com a superfície de volatilidade calibrada, as aplicações possíveis incluem a precificação de derivativos, gerenciamento de risco, simulações de Monte Carlo, análises de stress, entre outras.</p>

</div>
</div>
<h3>Bibliografia</h3>
<div id="refs" class="references">
<div id="ref-Heston1993">
<p>Heston, Steven L. 1993. “A Closed-Form Solution for Options with Stochastic Volatility with Applications to Bond and Currency Options.” <em>The Review of Financial Studies</em> 6 (2). Oxford University Press: 327–43.</p>
</div>
<div id="ref-Dupire1994">
<p>Dupire, Bruno. 1994. “Pricing with a Smile.” <em>Risk</em> 7 (1): 18–20.</p>
</div>
<div id="ref-Gatheral2004">
<p>Gatheral, Jim. 2004. “A Parsimonious Arbitrage-Free Implied Volatility Parameterization with Application to the Valuation of Volatility Derivatives.” <em>Presentation at Global Derivatives &amp; Risk Management, Madrid</em>.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="7">
<li id="fn7"><p>Veja mais detalhes no Capítulo <a href="smile.html#arbestatica">Smile de Volatilidade</a><a href="calibracao.html#fnref7">↩</a></p></li>
<li id="fn8"><p>Definição retirada de <a href="https://pt.wikipedia.org/wiki/Spline" class="uri">https://pt.wikipedia.org/wiki/Spline</a><a href="calibracao.html#fnref8">↩</a></p></li>
<li id="fn9"><p>A variância total é definida pelo produto entre a variância implícita e o tempo para expiração, <span class="math inline">\(w=\sigma^2_{imp}\cdot\tau\)</span>.<a href="calibracao.html#fnref9">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="smile.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="svi.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": false,
"google": false,
"linkedin": true,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rfbressan/vol_surface_gitbook/edit/master/06-metodos-calibracao.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"download": ["vol_surface_book.pdf", "vol_surface_book.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
